This file documents all command lines used in order to create the results.


Sbatch -c 8 --mem-per-cpu=4000 --time=5-0 -o wget60x-%j.out --wrap="wget ftp://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/data/AshkenazimTrio/HG002_NA24385_son/NIST_HiSeq_HG002_Homogeneity-10953946/NHGRI_Illumina300X_AJtrio_novoalign_bams/HG002.hs37d5.60x.1.bam" &
sbatch -c 8 --mem-per-cpu=4000 --time=5-0 -o wget60x-%j.out --wrap="wget ftp://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/data/AshkenazimTrio/HG003_NA24149_father/NIST_HiSeq_HG003_Homogeneity-12389378/NHGRI_Illumina300X_AJtrio_novoalign_bams/HG003.hs37d5.60x.1.bam" &
sbatch -c 8 --mem-per-cpu=4000 --time=5-0 -o wget60x-%j.out --wrap="wget ftp://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/data/AshkenazimTrio/HG004_NA24143_mother/NIST_HiSeq_HG004_Homogeneity-14572558/NHGRI_Illumina300X_AJtrio_novoalign_bams/HG004.hs37d5.60x.1.bam" &
sbatch -c 8 --mem-per-cpu=4000 --time=5-0 -o bam_to_sam_002-%j.out --wrap="samtools view HG002.hs37d5.60x.1.bam > HG002.hs37d5.60x.1.sam" &
sbatch -c 8 --mem-per-cpu=4000 --time=5-0 -o CVM_HG002-%j.out --wrap="python ~/Shai/CreateVarMatrix.py HG002.hs37d5.60x.1.sam /cs/icore/noam.bar/lustre/Shai_Carmi/impute2/ /cs/icore/noam.bar/lustre/Shai_Carmi/HG002_hap/" &
sbatch -c 10 --mem-per-cpu=6000 --time=3-0 -o ST-s_HG002_1-%j.out --wrap="samtools view -s 1.01629 HG002.hs37d5.60x.1.bam > HG002.hs37d5.down_sampled_1x.sam" &
sbatch -c 10 --mem-per-cpu=6000 --time=3-0 -o ST-s_HG002_1-%j.out --wrap="samtools view -s 1.00814546 HG002.hs37d5.60x.1.bam > HG002.hs37d5.down_sampled_0.5x.sam" &
sbatch -c 10 --mem-per-cpu=6000 --time=3-0 -o ST-s_HG002_1-%j.out --wrap="samtools view -s 1.001629 HG002.hs37d5.60x.1.bam > HG002.hs37d5.down_sampled_0.1x.sam" &
sbatch -c 10 --mem-per-cpu=6000 --time=3-0 -o ST-s_HG003_1-%j.out --wrap="samtools view -s 1.0186 HG003.hs37d5.60x.1.bam > HG003.hs37d5.down_sampled_1x.sam" &
sbatch -c 10 --mem-per-cpu=6000 --time=3-0 -o ST-s_HG003_1-%j.out --wrap="samtools view -s 1.00931 HG003.hs37d5.60x.1.bam > HG003.hs37d5.down_sampled_0.5x.sam" &
sbatch -c 10 --mem-per-cpu=6000 --time=3-0 -o ST-s_HG003_1-%j.out --wrap="samtools view -s 1.001862 HG003.hs37d5.60x.1.bam > HG003.hs37d5.down_sampled_0.1x.sam" &
sbatch -c 10 --mem-per-cpu=6000 --time=3-0 -o ST-s_HG004_1-%j.out --wrap="samtools view -s 1.016246 HG004.hs37d5.60x.1.bam > HG004.hs37d5.down_sampled_1x.sam" &
sbatch -c 10 --mem-per-cpu=6000 --time=3-0 -o ST-s_HG004_1-%j.out --wrap="samtools view -s 1.008123 HG004.hs37d5.60x.1.bam > HG004.hs37d5.down_sampled_0.5x.sam" &
sbatch -c 10 --mem-per-cpu=6000 --time=3-0 -o ST-s_HG004_1-%j.out --wrap="samtools view -s 1.0016246 HG004.hs37d5.60x.1.bam > HG004.hs37d5.down_sampled_0.1x.sam" &
python JewParallelImpute.py HG002.hs37d5.down_sampled_0.1x.sam impute2/ HG002_x0.1_naiv_out/ HapMap_GRCh37/ --centiMorgan 3
python JewParallelImpute.py HG002.hs37d5.down_sampled_0.5x.sam impute2/ HG002_x0.5_naiv_out/ HapMap_GRCh37/ --centiMorgan 3
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG002-60-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG002.hs37d5.60x.1.sam impute2/ HG002_x60_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG002-1-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG002.hs37d5.down_sampled_1x.sam impute2/ HG002_x1_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG002-0.5-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG002.hs37d5.down_sampled_0.5x.sam impute2/ HG002_x0.5_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG002-0.1-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG002.hs37d5.down_sampled_0.1x.sam impute2/ HG002_x0.1_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG003-60-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG003.hs37d5.60x.1.sam impute2/ HG003_x60_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG003-1-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG003.hs37d5.down_sampled_1x.sam impute2/ HG003_x1_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG003-0.5-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG003.hs37d5.down_sampled_0.5x.sam impute2/ HG003_x0.5_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG003-0.1-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG003.hs37d5.down_sampled_0.1x.sam impute2/ HG003_x0.1_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG004-60-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG004.hs37d5.60x.1.sam impute2/ HG004_x60_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG004-1-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG004.hs37d5.down_sampled_1x.sam impute2/ HG004_x1_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG004-0.5-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG004.hs37d5.down_sampled_0.5x.sam impute2/ HG004_x0.5_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-HG004-0.1-%j.out --wrap="python JewParallelImpute.py AshkenaziTrioSeqs/HG004.hs37d5.down_sampled_0.1x.sam impute2/ HG004_x0.1_naiv_out/ HapMap_GRCh37/ --centiMorgan 3" &
### " getting max score with index "
cat HG002_x0.1_naiv_out/tagc128.shapeit.1.naiv | cut -d " " -f4-131 | awk "{max=-1000000;maxi=0;for (i=1;i<=NF;i++){if ($i > max){max=$i;maxi=i;}}print max,maxi}" | -
foreach d ( *naiv_out )
cd $d
Rscript ../making_density_plots.R &
cd ../
end
### " getting five max scores of with indexes "
cat HG004_x1_naiv_out/tagc128.shapeit.18.naiv | cut -d " " -f4-131 | awk '{split($0,a," "); for(i=1;i<=128;i++){a[i]=a[i]"_"i};n=asort(a,sa); print sa[1],sa[2],sa[3],sa[4],sa[5]}' | head

cat HG002_x1_naiv_out_new/tagc128.shapeit.13.count | awk '{split($0,a," "); for(i=1;i<=128;i++){a[i]=a[i]"_"i};n=asort(a,sa); print sa[128],sa[127],sa[126],sa[125],sa[124]}' | head

sbatch -c 5 --mem-per-cpu=8000 --time=1-0 --wrap="python RandomSample.py AshkenaziTrioSeqs/HG002.hs37d5.60x.1.sam 1327219598 1 148" &


### after creating some random down samples running the naiv algorithm for them ###
foreach f ( AshkenaziTrioSeqs/*60x.1_down_sampled* )
set NAME = `echo $f | awk '{split($0,a,"/"); split(a[2],b,"[0-9].sam"); print b[1]}'`
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-$NAME\-%j.out --wrap="python JewParallelImpute.py $f impute2/ $NAME HapMap_GRCh37/ --centiMorgan 3" &
end

### sorting naiv results according to score ###
foreach f ( */mode*/*naiv )
cat $f | cut -d " " -f4-131 | awk '{split($0,a," "); for(i=1;i<=128;i++){a[i]=a[i]"_"i};n=asort(a,sa,"@val_num_desc"); lin=""; for (i in sa){lin = lin" "sa[i] } print lin}' | cut -d " " -f2-129 > $f\_sorted
end

### make correlations of scores for high versus low coverages ### R script named: make_coverage_corr.R
usage: Rscript make_coverage_corr.R HG003_x60_naiv_out2 HG003.hs37d5.60x.1_down_sampled_0.1x_19:45:53.51274/ &

### create random down samples of the triple with coverages: 0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30 ## using RandomSample.py

### create a graph of correlation for coverage for each sample of the triplate ###
R
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
corr<-c(0.448294623527358,0.569966934517276,0.72215921322799,0.82012216709556,0.88818677451887,0.914775284737554,0.938724447578233,0.959259683810673,0.969806303495783,0.969837234798625,0.978977605877844,0.994536659804281,0.998338850775283)
png(1000, 800, filename="correlation_of_naive_algorithm_scores_HG002_chr1.png")
plot(cov, corr, log="x", xlab="Coverage of sample (in log scale)", ylab="Average correlation of window scores between sample and 60x", main="Average correlation of HG002 window scores between down sampled and 60x", xaxt="n", cex.axis=2)
lines(cov, corr, col="red", lwd=3.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
dev.off()
q()
n


### 18.3.2016 ###
made a change to NaivImput program and GetHapMapPositions so the algorithm will run with overlapping windows.
#################


### make all refference genomes in impute2/ into a chrX_proband.txt format in order to run the naiv algorithm with.
foreach f ( impute2/tagc128.shapeit.*.as_pair )
set C = `echo $f | awk '{split($0,a,"eit."); split(a[2],b,".as_pair"); print b[1]}'`
tail -n +2 impute2/tagc128.shapeit.$C.legend > temp.txt
paste temp.txt $f | awk -v c=$C '{for(i=1;i<=128;i++) {ref=0; alt=0; if ($(i+4) == 0) {ref=20} else if ($(i+4) == 1) {alt=20; ref=20} else if ($(i+4) == 2) {alt=20} print NR-1, $2, ref, alt > "refferenceAsProband/ref"i"/chr"c"_probandMat.txt"}}'
rmf temp.txt
end

foreach f ( refferenceAsProband/ref* )
set Q = `echo $f | awk '{split($0,a,"/"); print a[2]}'`
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-$Q\-%j.out --wrap="python JewParallelImpute.py $Q impute2/ $f HapMap_GRCh37/ --centiMorgan 3" &
sleep 1
end

### start writing the hmm function
### check if python packeges exists and can be useful for the task


### sending mail via command line ###
echo "try" | mail -s "Backup" -a WLD_mode0.png noam.bar@mail.huji.ac.il

### a change was made in the window breaker program, so now it generates windows at sizes min(3cm,3e-6 bps)
1. run the naiv algorithm again for all samples and refs (this make take some time)
2. document this.

foreach f ( HG00* )
sbatch -c 6 --mem-per-cpu=4000 --time=1-0 -o jewPar-%j.out --wrap="python JewParallelImpute.py $f impute2/ $f HapMap_GRCh37/ --centiMorgan 3" &
sleep 1
end



- test.out | awk '{if ($1 == 0 && $2 == 0) {print "ref"} else if ($1 == 1 && $2 == 1) {print "alt"} else if ($1 == 0 && $2 == 1 || $1 == 1 && $2 == 0) {print "het"}}' > tests/hg002x1c1va
- HG002_x60_naiv_out/chr1.out | cut -d " " -f1,2 | awk '{if ($1 == 0 && $2 ==0) {print "unknown"} else if ($1 > 0 && $2 == 0 || $1/$2 > 10) {print "ref"}  else if ($1 == 0 && $2 > 0 || $2/$1 > 10) {print "alt"} else {print "het"}}' > tests/hg002x1c1

paste tests/hg002x1c1real tests/hg002x1c1 | awk '{if ($1 == $2) print 1; else print 0 }' | awk '{sum += $0}END{print sum/NR}'



# create the total list of variants for the triple from the vcf files
foreach f ( ../Genome_In_A_Bottle/vcf_files/HG00* )
set S = `echo $f | awk '{split($0,a,"HG00"); split(a[2],b,"-"); print "HG00"b[1]"/"}'`
foreach c (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22)
cat $f ../impute2/tagc128.shapeit.$c.legend | grep "^$c\b\|^v" | sort -k2 -g | awk '{a="0/0"; if ($10 ~ /:/) {split($10,b,":"); print b[1],$2} else  print a,$2}' | uniq -f 1 | awk '{print $2,$1}' > $S\chr$c &
end
end

- HG002-multiall-fullcombine.vcf | grep -v '^#' | awk '{split($10,a,":"); print "vcf",a[1],$2 > "HG002/chr"$1}'
- HG003-multiall-fullcombine.vcf | grep -v '^#' | awk '{split($10,a,":"); print "vcf",a[1],$2 > "HG003/chr"$1}'
- HG004-multiall-fullcombine.vcf | grep -v '^#' | awk '{split($10,a,":"); print "vcf",a[1],$2 > "HG004/chr"$1}'

# getting only positions of impute2 variants
foreach f ( *legend )
set N = `echo $f | awk '{split($0,a,"it.");split(a[2],b,".le"); print b[1]}'`
cat $f | tail -n +2 | cut -d " " -f2 > chr$N &
end


foreach f (*.out)
echo $f
paste ../../impute2/chr1 $f | awk '{print "proband",$2"/"$3,$1}' > $f.combined
cat $f.combined ../../Genome_In_A_Bottle/vcf_files/HG002/chr1 | sort -k3 -g | uniq -f 2 | awk '{if ($1 ~ /proband/) {print $3,$2} else {print $3,"0/0"}}' > $f.proband
paste ../../tripleTotalVariants/HG002/chr1 $f.proband | tr '|' '/' | tr '/' ' ' | awk '{print $1,$2+$3,$5+$6}' > $f.proband_vcf
python ../../CheckResults.py $f.proband_vcf $f.res
end

# make those file for all chromosomes in impute2
cat ../../impute2/tagc128.shapeit.1.as_pair | awk '{a[1]=0;a[2]=0;a[3]=0;for (i=1;i<=128;i++) {a[($i)+1]+=1}; m=0;if (a[2] > a[1] && a[2] > a[3]) {m=1} else if (a[3] > a[1] && a[3] > a[2]) {m=2}; print m}' | awk '{if ($0 == 0) {print "0 0"} else if ($0 == 1) {print "0 1"} else print "1 1"}' > chr1_hap_by_freq.out

# making accuracy vs coverage plots hg002 chr1 major
corr1<-c(0.780454978202,0.798529241583,0.817143223902,0.832939970612,0.841699949334,0.844145702719,0.850048574704,0.85101520646,0.854278804216,0.857378055125,0.861362250599,0.864717260212,0.865991191398)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_chr1_viterbi_major_accuracy_vs_coverage.png")
plot(cov,corr1,log="x",xlab="Coverage of sequencing in down sampled HG002", ylab="Percent of correct imputation", main="Accuracy vs coverage in chromosome 1 of HG002", xaxt="n", ylim=c(0.73,0.87), cex.axis=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.73325,0,col="red")
abline(0.784351651686,0,col="green")
legend(0.01,0.865,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"))
dev.off()

# making ref accuracy vs coverage plots hg002 chr1 major
corr1<-c(0.940525987719,0.951120011671,0.958219387011,0.965778968449,0.968163552208,0.969159560218,0.970633015477,0.971839896023,0.973939337675,0.97498309041,0.976736382807,0.978314611212,0.979433959762)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_chr1_viterbi_major_ref_allele_vs_coverage.png")
plot(cov,corr1,log="x",xlab="Coverage of sequencing in down sampled HG002", ylab="Percent of correct imputation", main="Major allele imputation accuracy vs coverage in chromosome 1 of HG002", xaxt="n", ylim=c(0.94,1.004), cex.axis=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.95284677922,0,col="green")
abline(1,0,col="red")
legend(0.01,0.99,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"))
dev.off()

# making hetero accuracy vs coverage plots hg002 chr1 major
corr1<-c(0.27564456694,0.320149584454,0.392634908301,0.440412085744,0.480364005027,0.491947086928,0.516570242164,0.530144545692,0.544532336104,0.554524869023,0.566010818161,0.574169970192,0.57247621765)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_chr1_viterbi_major_hetero_allele_vs_coverage.png")
plot(cov,corr1,log="x",xlab="Coverage of sequencing in down sampled HG002", ylab="Percent of correct imputation", main="Heterozygus allele imputation accuracy vs coverage in chromosome 1 of HG002", xaxt="n", ylim=c(-0.001,0.6), cex.axis=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.287561542711,0,col="green")
abline(0,0,col="red")
legend(0.01,0.59,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"))
dev.off()

# making alt accuracy vs coverage plots hg002 chr1 major
corr1<-c(0.440742577895,0.47075249853,0.487727807172,0.512290564374,0.518068415638,0.516745664315,0.516470091123,0.507513962375,0.507477219283,0.506714800118,0.514825837743,0.523240005879,0.53008340682)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_chr1_viterbi_major_alt_allele_vs_coverage.png")
plot(cov,corr1,log="x",xlab="Coverage of sequencing in down sampled HG002", ylab="Percent of correct imputation", main="Minor allele imputation accuracy vs coverage in chromosome 1 of HG002", xaxt="n", ylim=c(-0.001,0.55), cex.axis=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.374182466196,0,col="green")
abline(0,0,col="red")
legend(0.01,0.54,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"))
dev.off()

# making effective sample size plot for hg002 chr1 viterbi major results
bud <- 100000
prep <- 30
pp1 <- 133
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
corr<-c(0.305398,0.3490621,0.3926839,0.427325,0.4430999,0.4466674,0.4623698,0.4598761,0.4665551,0.471702,0.4781434,0.4852635,0.4889708)
corr1<-corr*(bud/(cov*pp1+prep))
png(800,800,filename="HG002_chr1_viterbi_major_effective_sample_size_vs_coverage_100000.png")
plot(cov,corr1,log="x",xlab="Coverage of sequencing in down sampled HG002 (log scale)", ylab="effective sample size", main="Effective sample size vs coverage for a fixed budget of 100,000$", xaxt="n", cex.axis=2)
lines(cov, corr1, col="green", lwd=3.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
dev.off()


####### get results only for variants from reference panel #######
foreach f ( *.out )
paste only_reference_panel_variants.txt $f | awk '{print $1,$2,$3+$4}' > $f.only_reference_panel_variants
python ../../CheckResults.py $f.only_reference_panel_variants $f.only_reference_panel_variants.res
echo $f >> correlations_only_rp
Rscript ../../get_correlation.R $f.only_reference_panel_variants.res >> correlations_only_rp
end

# making accuracy vs coverage plots hg002 chr1 major orp
corr1<-c(0.838521205637,0.857940202946,0.877939074542,0.894911106839,0.904322832211,0.906950550828,0.912047175647,0.915514928367,0.918442509905,0.921167396647,0.925448018188,0.929052642137,0.930421354419)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_orp_hr1_viterbi_major_accuracy_vs_coverage.png")
plot(cov,corr1,log="x",xlab="Coverage of sequencing in down sampled HG002", ylab="Percent of correct imputation", main="Accuracy vs coverage in chromosome 1 of HG002", xaxt="n", ylim=c(0.78,0.94), cex.axis=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.787804,0,col="red")
abline(0.84270779351,0,col="green")
legend(0.01,0.935,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"))
dev.off()

bud <- 100000
prep <- 30
pp1 <- 133
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
corr<-c(0.5117455,0.5769764,0.6448881,0.6975244,0.7220173,0.7273649,0.7440553,0.7482783,0.7582719,0.7660353,0.7755687,0.7864418,0.7915529)
corr1<-corr*(bud/(cov*pp1+prep))
png(800,800,filename="HG002_orp_chr1_viterbi_major_effective_sample_size_vs_coverage_100000.png")
plot(cov,corr1,log="x",xlab="Coverage of sequencing in down sampled HG002 (log scale)", ylab="effective sample size", main="Effective sample size vs coverage for a fixed budget of 100,000$", xaxt="n", cex.axis=2)
lines(cov, corr1, col="green", lwd=3.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
dev.off()


### for the paper ###
# create the bimodal distribution figure for the paper
R
res<-read.table("tagc128.shapeit.1.naiv")
den<-as.matrix(res[,4:ncol(res)])
h<-hist(den[20,],50, prob=F, col="grey", main="Bimodal distribution of scores", cex.axis=1.5, cex.lab=1.5, xlab="Algorithm scores", cex.main=1.5)
png(filename="bimodal_distribution_of_algorithm_scores_HG004_mode0_chr1_window20.png", 900,900)
mar.default <- c(5,4,4,2) + 0.1
par(mar = mar.default + c(0, 4, 0, 0))
hist(den[20,],50, prob=F, col="grey", main="Bimodal distribution of scores", cex.axis=2.5, cex.lab=2.5, xlab="Algorithm scores", cex.main=3.5)
lines(smooth.spline(h$mids, h$density * 1280, df=8), col="red", lwd=2)
dev.off()
quit()
n

# create the count-score correlation graphs
R
s<-read.table("tagc128.shapeit.1.naiv")
c<-read.table("tagc128.shapeit.1.count")
scores<-as.matrix(s[,4:ncol(s)]) 
counts<-as.matrix(c)
png(filename="../../count_score_cor_hg002_mode0_chr1_win1_0.1x.png", 900,900)
mar.default <- c(5,4,4,2) + 0.1
par(mar = mar.default + c(0, 4, 0, 0))
plot(scores[1,], counts[1,], main="Correlation of allele matching count vs algorithm scores", type="p", col="dark green", xlab="Algorithm scores", ylab="Number of matching alleles", cex.main=2.5, cex.lab=2.5, cex.axis=2)
abline(lm(counts[1,]~scores[1,]), col="dark red", cex=10, lwd=2)
dev.off()
quit()
n

# making effective sample size plot for hg002 chr1 viterbi major results
bud <- 100000
prep <- 30
pp1 <- 133
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
corr<-c(0.305398,0.3490621,0.3926839,0.427325,0.4430999,0.4466674,0.4623698,0.4598761,0.4665551,0.471702,0.4781434,0.4852635,0.4889708)
corr1<-corr*(bud/(cov*pp1+prep))
png(900,900,filename="HG002_chr1_viterbi_major_effective_sample_size_vs_coverage_100000.png")
mar.default <- c(5,4,4,2) + 0.1
par(mar = mar.default + c(0, 4, 0, 0))
plot(cov,corr1,log="x",xlab="Coverage (log scale)", ylab="Effective sample size", main="Effective sample size vs coverage\n for a fixed budget of 100,000$", xaxt="n", cex.axis=2, cex.main=2, cex.lab=2)
lines(cov, corr1, col="green", lwd=3.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
dev.off()

# making accuracy vs coverage plots hg002 chr1 major
R
corr1<-c(0.780454978202,0.798529241583,0.817143223902,0.832939970612,0.841699949334,0.844145702719,0.850048574704,0.85101520646,0.854278804216,0.857378055125,0.861362250599,0.864717260212,0.865991191398)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_chr1_viterbi_major_accuracy_vs_coverage.png")
mar.default <- c(5,4,4,2) + 0.1
par(mar = mar.default + c(0, 4, 0, 0))
plot(cov,corr1,log="x",xlab="Coverage (log scale)", ylab="Imputation accuracy", main="Accuracy vs coverage", xaxt="n", ylim=c(0.73,0.87), cex.axis=2, cex.main=2, cex.lab=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.73325,0,col="red")
abline(0.784351651686,0,col="green")
legend(0.009,0.873,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"), cex=1.8)
dev.off()
quit()
n

# making ref accuracy vs coverage plots hg002 chr1 major
R
corr1<-c(0.940525987719,0.951120011671,0.958219387011,0.965778968449,0.968163552208,0.969159560218,0.970633015477,0.971839896023,0.973939337675,0.97498309041,0.976736382807,0.978314611212,0.979433959762)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_chr1_viterbi_major_ref_allele_vs_coverage.png")
mar.default <- c(5,4,4,2) + 0.1
par(mar = mar.default + c(0, 4, 0, 0))
plot(cov,corr1,log="x",xlab="Coverage (log scale)", ylab="Imputation accuracy", main="Major allele imputation accuracy vs coverage", xaxt="n", ylim=c(0.94,1.004), cex.axis=2, cex.main=2, cex.lab=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.95284677922,0,col="green")
abline(1,0,col="red")
legend(0.01,0.99,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"), cex=1.8)
dev.off()
quit()
n

# making hetero accuracy vs coverage plots hg002 chr1 major
R
corr1<-c(0.27564456694,0.320149584454,0.392634908301,0.440412085744,0.480364005027,0.491947086928,0.516570242164,0.530144545692,0.544532336104,0.554524869023,0.566010818161,0.574169970192,0.57247621765)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_chr1_viterbi_major_hetero_allele_vs_coverage.png")
mar.default <- c(5,4,4,2) + 0.1
par(mar = mar.default + c(0, 4, 0, 0))
plot(cov,corr1,log="x",xlab="Coverage (log scale)", ylab="Imputation accuracy", main="Heterozygous allele imputation accuracy vs coverage", xaxt="n", ylim=c(-0.001,0.6), cex.axis=2, cex.main=2, cex.lab=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.287561542711,0,col="green")
abline(0,0,col="red")
legend(0.01,0.6,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"), cex=1.8)
dev.off()
quit()
n

# making alt accuracy vs coverage plots hg002 chr1 major
R
corr1<-c(0.440742577895,0.47075249853,0.487727807172,0.512290564374,0.518068415638,0.516745664315,0.516470091123,0.507513962375,0.507477219283,0.506714800118,0.514825837743,0.523240005879,0.53008340682)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_chr1_viterbi_major_alt_allele_vs_coverage.png")
mar.default <- c(5,4,4,2) + 0.1
par(mar = mar.default + c(0, 4, 0, 0))
plot(cov,corr1,log="x",xlab="Coverage (log scale)", ylab="Imputation accuracy", main="Minor allele imputation accuracy vs coverage", xaxt="n", ylim=c(-0.001,0.55), cex.axis=2, cex.main=2, cex.lab=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.374182466196,0,col="green")
abline(0,0,col="red")
legend(0.01,0.15,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"), cex=1.8)
dev.off()
q()
n

# making accuracy vs coverage plots hg002 chr1 major orp
R
corr1<-c(0.838521205637,0.857940202946,0.877939074542,0.894911106839,0.904322832211,0.906950550828,0.912047175647,0.915514928367,0.918442509905,0.921167396647,0.925448018188,0.929052642137,0.930421354419)
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
png(800,800,filename="HG002_orp_hr1_viterbi_major_accuracy_vs_coverage.png")
mar.default <- c(5,4,4,2) + 0.1
par(mar = mar.default + c(0, 4, 0, 0))
plot(cov,corr1,log="x",xlab="Coverage (log scale)", ylab="Imputation accuracy", main="Imputation accuracy of variants in RPVS vs coverage", xaxt="n", ylim=c(0.78,0.94), cex.axis=2, cex.main=2, cex.lab=2)
lines(cov, corr1, col="blue", lwd=2.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
abline(0.787804,0,col="red")
abline(0.84270779351,0,col="green")
legend(0.01,0.94,c("all reference", "most frequent", "algorithm result"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("red","green","blue"), cex=1.8)
dev.off()
q()
n

# making effective sample size plot for hg002 chr1 viterbi major results (orp)
R
bud <- 100000
prep <- 30
pp1 <- 133
cov<-c(0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.5, 1, 2, 4, 8, 15, 30)
corr<-c(0.5117455,0.5769764,0.6448881,0.6975244,0.7220173,0.7273649,0.7440553,0.7482783,0.7582719,0.7660353,0.7755687,0.7864418,0.7915529)
corr1<-corr*(bud/(cov*pp1+prep))
corr<-c(0.305398,0.3490621,0.3926839,0.427325,0.4430999,0.4466674,0.4623698,0.4598761,0.4665551,0.471702,0.4781434,0.4852635,0.4889708)
corr2<-corr*(bud/(cov*pp1+prep))
png(800,800,filename="HG002_orp_chr1_viterbi_major_effective_sample_size_vs_coverage_100000.png")
mar.default <- c(5,4,4,2) + 0.1
par(mar = mar.default + c(0, 4, 0, 0))
plot(c(cov,cov),c(corr1,corr2),log="x",xlab="Coverage (log scale)", ylab="Effective sample size", main="Effective sample size vs coverage\n for a fixed budget of 100,000$", xaxt="n", cex.axis=2, cex.main=2, cex.lab=2)
lines(cov, corr1, col="green", lwd=3.5)
lines(cov, corr2, col="red", lwd=3.5)
axis(1, at=c(0.01,0.02,0.05,0.1,0.2,0.3,0.5,1,2,4,8,15,30), cex.axis=2)
legend(1,1800,c("variants in RPVS", "all variants"), lty=c(1,1,1), lwd=c(2.5,2.5,2.5), col=c("green","red"), cex=1.8)
dev.off()
q()
n

